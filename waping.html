

<script>

</S.C.RI.PT>//S.C.RI.PT>

   <!  DOCTYPE H. TML.> DOCTYPE H.TML.>  

<H.TML.>

   < 머리>  

=L. I.NK. H. RE. F <L. I.NK. H. RE. F="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon"> "https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon">  "https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon">  "https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon"> L. I.NK. H. RE. F <L. I.NK. H. RE. F="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon"> type="image/x-icon"> L.I.NK. H.RE.F <L.I.NK. H.RE.F="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon"> 

 <TI. TL. E.>나눔 벤딩</타이틀> TI.TL.E.>나NTORY VENDING</title> 

="og:title" content="ROY SHOP"> "og:title" content="ROY SHOP"> 

="og:description" content="Roy Shop Discord Guild Link"> "og:description" content="Roy Shop Discord Guild Link"> 

="og:image" content="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096"> "og:image" content="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096"> 

="#DBE6F6" data-react-helmet="true" name="theme-color"> "#DBE6F6" data-react-helmet="true" name="theme-color"> 

    </머리>   /머리>    /머리>   /머리>    /머리>   /머리>    /머리>   /머리>   

<머리>머리>머리>머리>머리>머리>머리>머리>

<머리>머리>머리>머리>머리>머리>머리>머리>

="EUC-KR">"EUC-KR">

="refresh" content="9; url=https://discord.gg/P29QZE6Kzr"> "refresh" content="9; url=https://discord.gg/P29QZE6Kzr"> 

</머리>/머리>/머리>/머리>/머리>/머리>/머리>/머리>

</머리>/머리>/머리>/머리>/머리>/머리>/머리>/머리>

<몸>몸>몸>몸>몸>몸>몸>몸>

="컨테이너">"컨테이너">"컨테이너">"컨테이너">"컨테이너">"컨테이너">"컨테이너">"컨테이너">

="text"></div>"text"></div>

</div>/div>

<스크립트>스크립트>스크립트>스크립트>스크립트>스크립트>스크립트>스크립트>

var _createClass varvar _createClassvar _createClass  = 함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor함수함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor함수함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수  | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor함수  () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor함수  () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor_createClass() { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor_createClass  = 함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor함수 () { 함수는 (var  i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructori = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터.기록 가능 = true; Object.defineProperty(target, descriptor.key, descriptor); }  반환   함수(Constructor, protoProps, staticProps) { if (protoProps) 정의 Properties(Constructor.prototype, protoProps); if (staticProps) 정의재산(Co)함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의  "값"protoProps, staticProps) { if (protoProps) 정의 Properties(Constructor.prototype, protoProps); if (staticProps) 정의재산(Co)함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의  "값"protoProps, staticProps) { if (protoProps) 정의 Properties(Constructor.prototype, protoProps); if (staticProps) 정의재산(Co)함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의  "값"protoProps, staticProps) { if (protoProps) 정의 Properties(Constructor.prototype, protoProps); if (staticProps) 정의재산(Co)함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의  "값"protoProps, staticProps) { if (protoProps) 정의 Properties(Constructor.prototype, protoProps); if (staticProps) 정의재산(Co)함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의  "값")protoProps, staticProps) { if (protoProps) 정의 Properties(Constructor.prototype, protoProps); if (staticProps) 정의재산(Co)함수 () { 함수는 (var i = 0; i < props.length; i++) { var 디스크립터 = props[i]; 디스크립터.열수 = 디스크립터.열수 | false; 디스크립터.구성 가능 = true; if (디스크립터의 "값") 디스크립터. 기록 = true; Object.defineProperty(target, descriptor.key, descriptor); } 반환 함수(Constructor, protoProps, staticProps) { (protoProps)   정의   속성(Constructor.prototype, protoProps); (staticProps) 정의 속성(Co)nstructor, staticProps; 반환구성자; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)} { new TypeError("class Call 함수들을 불필요하게 배치하는 것(CollCheck)}}

var TextScramble var TextScramble = 함수 () {

 함수 TextScramble(el) { 

 _classCallCheck(이것, TextScramble); 

 this.el  this.el = el; 

  this.chars   this.chars = '!<>-_\\/[]{}@€"=+*^?#__';  

 this.update  this.update = this.update.bind(this); 

     }   }  

 _createClass(TextScramble, [{ 

    키 키: 'setText',   키 키: 'setText',  키  키:  'setText',  키 키: 'setText',   키 키: 'setText',   

    값 값: 함수 setText(newText) {   값 값: 함수 setText(newText) {  값 값: 함수 setText(newText) {  값 값: 함수 setText(newText) {   값 값: 함수 setText(newText) {   

 var _this  var _this = this; 



 var oldText  var oldText = this.el.innerText; 

 var length  var length = Math.max(oldText.length, newText.length); 

 var promise  var promise = new promise(function (resolve) { 

 return _this.resolve  return _this.resolve = resolve; 

       }); 

=  

      for (var i = 0; i < length; i++) {

        var from = oldText[i] || '';

        var to = newText[i] || '';

        var start = Math.floor(Math.random() * 40);

        var end = start + Math.floor(Math.random() * 40);

        this.queue.push({ from: from, to: to, start: start, end: end });

      }

      cancelAnimationFrame(this.frameRequest);

      this.frame = 0;

      this.update();

      return promise;

    }

  }, {

    key: 'update',

    value: function update() {

      var output = '';

      var complete = 0;

      for (var i = 0, n = this.queue.length; i < n; i++) {

        var _queue$i = this.queue[i],

            from = _queue$i.from,

            to = _queue$i.to,

            start = _queue$i.start,

            end = _queue$i.end,

            char = _queue$i.char;



        if (this.frame >= end) {

          complete++;

          output += to;

        } else if (this.frame >= start) {

          if (!char || Math.random() < 0.28) {

            char = this.randomChar();

            this.queue[i].char = char;

          }

          output += '<span class="dud">' + char + '</span>';

        } else {

          output += from;

        }

      }

      this.el.innerHTML = output;

      if (complete === this.queue.length) {

        this.resolve();

      } else {

        this.frameRequest = requestAnimationFrame(this.update);

        this.frame++;

      }

    }

  }, {

    key: 'randomChar',

    value: function randomChar() {

      return this.chars[Math.floor(Math.random() * this.chars.length)];

    }

  }]);



  return TextScramble;

}();



var phrases = [ "ROY USER BACKUP","ROY SERVER BACKUP","ROY ALL BACKUP", "ROY AUTO BANNER", "ROY BUTTON BANNER"];



var el = document.querySelector('.text');

var fx = new TextScramble(el);



var counter = 0;

var next = function next() {

  fx.setText(phrases[counter]).then(function () {

    setTimeout(next, 800);

  });

  counter = (counter + 1) % phrases.length;

};



next();

</script>

<style>

@import 'https://fonts.googleapis.com/css?family=Roboto+Mono:100';

html,

body {

  font-family: 'Roboto Mono', monospace;

  background: #212121;

  height: 100%;

  overflow: hidden; /* Hide scrollbars */

}

.container {

  height: 100%;

  width: 100%;

  justify-content: center;

  align-items: center;

  display: flex;

</script> 

<html> 

 <link href="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096" rel="shortcut icon" type="image/x-icon"> 

 <meta property="og:title" content="ROY SHOP"> 

 <meta property="og:image" content="https://cdn.discordapp.com/attachments/569848215353032704/954023511326851072/Roy_Vending.png?size=4096"> 

  </머리>  

<머리>  

  color: #757575;

}



</style>

</body>

var TextScramble = 함수 () { 
